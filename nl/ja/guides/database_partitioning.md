---

copyright:
  years: 2019
lastupdated: "2019-03-27"

keywords: database shards, non-partitioned databases, partition key, global query, partition query, create partition database, create partition query index

subcollection: cloudant

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}
{:deprecated: .deprecated}

<!-- Acrolinx: 2018-08-17 -->

# データベースのパーティショニング
{: #database-partitioning}

{{site.data.keyword.cloudant_short_notm}} のパーティション・データベース機能は、現在ベータ・モードです。パーティション・データベースは、実動のアプリケーションの使用では使用しないでください。この機能は、すべての {{site.data.keyword.cloudant_short_notm}} 環境で提供が開始され、間もなく一般出荷可能になります。
{: important}

{{site.data.keyword.cloudantfull}} では、次の 2 つのタイプのデータベースがサポートされます。

- パーティション
- 非パーティション

_パーティション_・データベースには、大きなパフォーマンス上およびコスト面でのメリットがありますが、データのロジカル・パーティショニングの指定が必要になります。これについては、後で詳しく説明します。

または、_非パーティション_・データベースを作成することもできます。このタイプのデータベースは、パーティショニング・スキームを定義する必要がないため処理が容易ですが、作成できるのはグローバル副次索引のみになります。

{{site.data.keyword.cloudant_short_notm}} では、長期で最良のデータベース・パフォーマンスを得るためにパーティション・データベースの使用を強く推奨しています。パーティション・データベースでは、データ・モデルは文書のロジカル・パーティショニングを利用できます。

データベースのパーティショニング・タイプはデータベースの作成時に設定されます。データベースを作成するときに、`partitioned` 照会ストリング・パラメーターを使用して、データベースをパーティション化するかどうかを設定します。`partitioned` のデフォルトは `false` で、後方互換性が維持されます。

既存のデータベースのパーティショニング・タイプは変更できません。

## データベース・シャード
{: #database-shards}

本資料を読む前に、{{site.data.keyword.cloudant_short_notm}} 内の
[シャーディングの概念](/docs/services/Cloudant?topic=cloudant-how-is-data-stored-in-ibm-cloudant-#how-is-data-stored-in-ibm-cloudant-)を理解している必要があります。

## 非パーティション・データベース
{: #non-partitioned-databases}

非パーティション・データベースは、古い方のタイプの {{site.data.keyword.cloudant_short_notm}} データベースで、CouchDB または {{site.data.keyword.cloudant_short_notm}} を以前使用していたユーザーにとっては、よく知っているデータベースになります。

非パーティション・データベース内では、文書は文書 ID の変換に基づいて恣意的にシャードに配布されます。したがって、文書の ID と配布されるシャードとの間には実際の関係はありません。よく似ている文書 ID を持つ文書は、同じシャードに配置される可能性が高くなります。

非パーティション・データベースでは、以下で詳しく説明するグローバル照会だけが提供されます。

## パーティション・データベース
{: #partitioned-databases}

パーティション・データベースは、新しい方のタイプの {{site.data.keyword.cloudant_short_notm}} データベースになります。パーティション・データベース内では、文書は、パーティション・データベース内の文書の文書 ID の一部である_パーティション・キー_を使用して複数の論理区画に形成されます。すべての文書は 1 つのパーティションに割り当てられ、通常、多くの文書に同じパーティション・キーが与えられます。パーティションの 1 次 JSON データとその索引は同一場所に配置されます。これは、データベースがパーティション内のデータをより効率的に照会できることを意味します。

パーティション・データベースでは、パーティション照会とグローバル照会の両方が提供されます。パーティション照会はデータベース・クラスター内のデータ・レイアウトを利用して、改善されて、よりスケーラブルな照会パフォーマンスを提供します。それに加え、パーティション照会は、多くの場合、グローバル照会よりも安くなります。

パーティション・データベースではグローバル照会とパーティション照会両方の利点が提供されるため、{{site.data.keyword.cloudant_short_notm}} では新しいアプリケーションでそれらを活用することをお勧めしています。

## 良いパーティション・キーとは
{: #what-makes-a-good-partition-key-}

{{site.data.keyword.cloudant_short_notm}} の新しい*パーティション・データベース*機能の使用を検討している場合、パーティション・キーの選択がとても重要になります。パーティション・キーの条件としては次のようなものがあります。

- 多くの値を持っている - 小さなパーティションが多くある方が、少ない数の大きいパーティションがあるより適しています。
- ホット・スポットがない - 1 つのパーティションがワークロードの高い比率を処理するようなシステムを設計しないようにしてください。処理が複数のパーティションに均等に分散されると、データベースの実行がより円滑になります。
- 繰り返しがある - 各パーティション・キーが固有の場合は、1 つのパーティションにつき 1 つの文書があります。パーティション・データベースを最大限に活用するには、1 つのパーティションにつき複数の文書 (論理的に一緒に属す文書) がある必要があります。

いくつかのユース・ケースと、パーティション・キーにとって良い選択と悪い選択を見てみましょう。

| ユース・ケース                   | 説明                 |パーティション・キー | 有効性                                                                                           |
|----------------------------|-----------------------------|---------------|------------------------------------------------------------------------------------------------------------------|
| e-コマース・システム - オーダー | 1 オーダーにつき 1 文書     | order_id      | 中間 - 1 つのパーティションにつき 1 つの文書というのは問題ないが、パーティション照会のメリットが得られない。          |
| e-コマース・システム - オーダー | 1 オーダーにつき 1 文書     | user_id       | 良い - ユーザーのすべてのオーダーが一緒に保持される。                                                             |
| e-コマース・システム - オーダー | 1 オーダーにつき 1 文書     | status        | 悪い - 少数の状況値 (provisional、paid、refunded、cancelled) でオーダーをグループ化すると、過度に大きいパーティションが少数作成される。 |
| ブログ作成プラットフォーム          | 1 回のブログ投稿につき 1 文書 | author_id     | 良い - 作成者の数が多い限りは良い。各作成者の投稿を容易に照会できる。                              |
| IOT - センサー信号。     | 1 つの信号につき 1 文書    | device_id     | 良い - デバイスの数が多い限り良い。あるデバイスが、他のデバイスより多くの信号を生成しないようにする。|
| IOT - センサー信号。     | 1 つの信号につき 1 文書    | date          | 悪い - 現在の信号により、現在日付のパーティションに「ホット・スポット」が作成される。|

ユース・ケースの中には、パーティション・キーにとって実行可能な選択がないものもあります。このようなシチュエーションでは、非パーティション・データベースが最良の選択である可能性が高くなります。例えば、E メール・アドレス、パスワード・ハッシュ、および最終ログイン日付を格納しているユーザーのデータベースがこれにあたります。これらのどのフィールドも適切なパーティション・キーにはならないため、通常の非パーティション・データベースを代わりに使用する必要があります。

## 照会
{: #querying}

このセクションでは、グローバル照会とパーティション照会で {{site.data.keyword.cloudant_short_notm}} のどちらの照会タイプが使用可能かを説明します。そしてそれとともに、基本となる照会メカニズムの概要を説明して、アプリケーションで行う必要があるそれぞれの照会にどちらの照会メカニズムが最適かを選択できるようにします。

### グローバル照会
{: #global-querying}

グローバル照会は、次の索引タイプに対して実行できます。

- {{site.data.keyword.cloudant_short_notm}} 照会
- ビュー
- 検索
- 地域別

グローバル照会を行うとき、データベースはデータベース内の全データにわたってスキャッター・ギャザー操作を実行する必要があります。これは、多くの個別のデータベース・サーバーの要求を行うことを意味します。API 調整ノードは、これらのすべてのサーバーから応答を受信し、それらを結合して、クライアントへの 1 つの応答を形成します。このためには、データのバッファリングと、例えばデータのソートが必要な場合は、クライアントへの応答の遅延が必要になります。

### パーティション照会
{: #partition-querying}

パーティション照会は、次の索引タイプに対して実行できます。

- {{site.data.keyword.cloudant_short_notm}} 照会
- ビュー
- 検索

パーティション照会を行うとき、データベースが照会できるのは 1 つのパーティション内のデータのみになります。パーティションのデータは 1 つのシャード (3 つのレプリカをもつ) 内のみにあるため、API 調整ノードは、多くのサーバーからの応答を結合する必要はなく、そのデータをホストしているサーバーに直接要求を行うことができます。また、実行する結合ステップがないので、応答をバッファリングする必要もありません。したがって、データはより速くクライアントに到着します。

それに加え、データベースのサイズが大きくなるにしたがって、シャードの数も増やす必要があります。これにより、グローバル照会を使用しているときに、データをホストしているサーバーに対して API 調整ノードが行う必要がある照会の数が直接増加します。しかし、パーティション照会を使用しているときは、シャードの数が、API 調整ノードが接続する必要があるサーバーの数に影響を与えることはありません。この数が少ない数の状態のときは、グローバル照会と違い、データ・サイズを増加しても照会の待ち時間に影響はありません。

## 例: IoT 信号データのパーティショニング
{: #example-partitioning-iot-reading-data}

この内容は非常に抽象的なので、例を使って具体的に考えてみましょう。IoT ドメインを使用し、{{site.data.keyword.cloudant_short_notm}} をデバイス信号のヒストリアンとして使用する場合について考えてみます。デバイスが、道路や橋といったインフラストラクチャーにセンサー信号を提供していると仮定します。

以下のことを仮定します。

- 信号を報告するデバイスの数は数百または数千個。
- 各デバイスには固有の ID がある。
- 各インフラストラクチャーには固有の ID がある。
- インフラストラクチャー間でデバイスの移動はない。
- 各デバイスは、10 秒ごとに {{site.data.keyword.cloudant_short_notm}} に信号を書き込む。この送信は、{{site.data.keyword.cloudant_short_notm}} へのメッセージ・バスを介して行われる可能性が高い。

非パーティション・データベースでは、{{site.data.keyword.cloudant_short_notm}} に文書 ID を生成させる場合があります。代わりに、デバイス ID で文書を指定して、タイム・スタンプを記録するという方法もあります。

2 番目の方法を使用すると、次のような文書 ID が作成されます。

```
device-123456:20181211T11:13:24.123456Z
```

このタイム・スタンプは、エポック・タイム・スタンプの場合もあります。

この方法を使用すると、パーティション化された索引を使用して各デバイスのデータを効率的に照会することができますが、複数のデバイス (例えば、ある特定のインフラストラクチャー上のすべてのデバイス) のビューを作成するためにグローバル索引の使用が必要な可能性があります。

例証の目的で、このシナリオを少し複雑にして、アプリケーションが多くの場合、個別のデバイスではなく、ある特定のインフラストラクチャーのすべてのセンサー・データを読み取る必要があると仮定してみましょう。

このアプリケーションでは、インフラストラクチャー項目による照会を最も効率的にしたいので、インフラストラクチャーでデータをパーティション化する方が、ID でパーティション化するよりも妥当です。こうすると、ある特定のインフラストラクチャーのすべてのデバイスを 1 つのグループとしてより効率的に照会することができます。

デバイスによるまれな照会については、次の 2 つの方法があります。

1. デバイスをキーとしたグローバル索引を作成して、これを照会します。個別のデバイスへの照会がまれであり、繰り返されない場合は、この方が効果的です。
2. デバイスからインフラストラクチャーのグローバル索引マッピングを作成し、インフラストラクチャー・パーティションに対してパーティション照会を実行します。マッピングはキャッシュできるので、ある特定のデバイスに対する繰り返し照会が使用される場合、この方法は理にかなっています。私たちが使用するアプリケーションにはこの事例が当てはまると仮定します。 

これがどのように機能するか見てみましょう。次の 4 つの照会を見ていきます。

1. あるインフラストラクチャーの常時の信号。
1. あるインフラストラクチャーの今日の信号。
1. 特定のデバイスの常時の信号。
1. 特定のデバイスの今日の信号。

### データベースの作成
{: #creating-the-database}

`readings` というデータベースと `acme` というアカウントを使用します。これをパーティション・データベースとして作成するには、以下のようにデータベース作成要求に `partitioned` 引数として `true` を渡します。

```
curl -XPUT 'https://acme.cloudant.com/readings?partitioned=true'
```

### 文書構造
{: #document-struture}

まず、作業する単純な文書フォーマットを定義します。

```json
{
    "deviceID": "device-123456",
    "infrastructureID": "bridge-9876",
    "ts": "20181211T11:13:24.123456Z",
    "reading": {
        "temperature": {"value": 12, "unit": "c"}
    }
}
```

この文書では、インフラストラクチャーに基づいたパーティショニング・スキームを使用するので、次のように、文書 ID には、パーティション・キーとしてインフラストラクチャー ID が含まれ、文書キーとしてデバイスとタイム・スタンプの両方が含まれる可能性があります。

```
bridge-9876:device-123456-20181211T11:13:24.123456Z
```

### 索引の作成
{: #creating-indexes}

上記の照会では、次の 2 つの索引が必要になります。

1. デバイス ID をインフラストラクチャー ID にマップするグローバル索引。
2. デバイス ID を信号にマップするパーティション化された索引。

#### グローバル・ビュー索引の作成
{: #creating-a-global-view-index}

ビュー索引は、単純なデバイス ID からインフラストラクチャー ID へのマッピングを行うための最も効率的な方法です。これを定義するには、この索引はグローバルなので、`options.partitioned` を `false` に設定して設計文書をアップロードします。実際の `map` 関数ではフィールドの存在に関してより防御的になることをお勧めしますが、次のようなものになります。

```json
{
    "_id": "_design/infrastructure-mapping",
    "options": {"partitioned": false},
    "views": {
        "by-device": {
            "map": "function(doc) { emit(doc.deviceID, doc.infrastructureID) }"
        }
    }
}
```

`./view.json` に上記の文書があると仮定すると、これは次を使用してデータベースにアップロードされます。

```
curl -XPOST https://acme.cloudant.com/readings -d @view.json
```

#### パーティション化された {{site.data.keyword.cloudant_short_notm}} 照会索引の作成
{: #creating-a-paritioned-ibm-cloudant-query-index}

パーティションからある特定のデバイスの信号を返すには、{{site.data.keyword.cloudant_short_notm}} 照会索引を使用できます。このために、`true` に設定された `partitioned` フィールドを含む索引定義で `_index` に `POST` します。 

照会索引の定義の場合、`partitioned` フィールドは `options` オブジェクト内にネストされません。
{: note}

ここで使用する照会では、次の 2 つのパーティション化された索引が必要です。

1. タイム・スタンプによる
2. デバイス ID とタイム・スタンプによる

タイム・スタンプでパーティション化された索引の定義は次のようになります。

```json
{
   "index": {
      "fields": [
         "ts"
      ]
   },
   "name": "timestamped-readings",
   "type": "json",
   "partitioned:" true
}
```

上記の文書が `./query-index1.json` と仮定した場合、次のコマンドを使用して索引をデータベースにアップロードします。

```
curl -XPOST https://acme.cloudant.com/readings/_index -d @query-index1.json
```

デバイス ID とタイム・スタンプでパーティション化された索引の定義は次のようになります。

```json
{
   "index": {
      "fields": [
         "deviceID",
         "ts"
      ]
   },
   "name": "deviceID-readings",
   "type": "json",
   "partitioned:" true
}
```

上記の文書が `./query-index2.json` と仮定した場合、次のコマンドを使用して索引をデータベースアップロードします。

```
curl -XPOST https://acme.cloudant.com/readings/_index -d @query-index2.json
```

### 照会を行う
{: #making-queries}

全体として次の 4 つの照会を行います。

1. あるインフラストラクチャーの常時の信号。
1. あるインフラストラクチャーの今日の信号。
1. 特定のデバイスの常時の信号。
1. 特定のデバイスの今日の信号。

#### インフラストラクチャーのすべての信号の検出
{: #finding-all-readings-for-a-piece-of-infrastructure}

パーティションはインフラストラクチャーをベースとしているので、パーティションには `_all_docs` を使用できます。例えば、`bridge-1234` インフラストラクチャーのすべての信号を照会する場合、次のようになります。

```
curl -XGET \
    'https://acme.cloudant.com/readings/_partition/bridge-1234/_all_docs?include_docs=true'
```

#### インフラストラクチャーの最新の信号の検出
{: #finding-recent-readings-for-a piece-of-infrastructure}

この照会は、パーティション化された `timestamped-readings` 索引を使用する必要があります。今日の信号を取得するには、パーティションに対して次のような照会を実行できます。

_query.json, assuming today is 13th Dec 2018:_

```json
{
    "selector": {
        "ts": { "$gte": "20181213"}
    }
}
```

{{site.data.keyword.cloudant_short_notm}} に要求を実行するとき、パーティションは次のように HTTP パスに埋め込まれます。

```
curl -XPOST \
    'https://acme.cloudant.com/readings/_partition/bridge-1234/_find' \
    -d @query.json
```

#### デバイスのインフラストラクチャー ID の検出
{: #finding-the-infrastructure-id-for-a-device}

まだ実行されていない、次の 2 つの照会があります。

1. 特定のデバイスの常時の信号。
2. 特定のデバイスの今日の信号。

これらの 2 つの照会については、グローバル `by-device` 索引を使用してデバイスのパーティションを見つける必要があります。次に、各パーティションで信号を照会します。個別のデバイスの信号を照会するためにグローバル索引を使用することもできますが、デバイスからインフラストラクチャー ID へのマッピングはキャッシュ可能性が高く、決して変わりません。したがって、この方法を使用すると、多くの場合、ほとんどの要求に対して、より安くてより効率的なパーティション照会を使用することができます。

ある特定のアプリケーションでデバイスからインフラストラクチャーのマッピングのキャッシュがうまく機能しない場合は、グローバル索引を使用してデバイス信号を直接照会した方が、より効率的な場合があります。

デバイスの関連パーティションを見つけるには、次のようにデバイス ID をキーとして送信して `by-device` ビューを照会します。

```
curl -XGET \
  'https://acme.cloudant.com/readings/_design/infrastructure-mapping/_view/by-device?keys=["device-123456"]&limit=1'
```

返される内容は以下のとおりです。

```json
{"total_rows":5,"offset":0,"rows":[
{
    "id":"bridge-9876:device-123456-20181211T11:13:24.123456Z",
    "key":"device-123456",
    "value":"bridge-9876"
}
]}
```

パーティション・キーは、組み込まれている行の `value` フィールドにあります。`bridge-9876`.

#### デバイスのすべての結果の照会
{: #querying-for-all-results-for-a-device}

デバイスの結果を取得するには、`bridge-9876` パーティション内のデバイスに対してパーティション照会を実行します。グローバル照会を実行しているかのように、標準の {{site.data.keyword.cloudant_short_notm}} の照会選択子が使用されます。

_query.json:_

```json
{
   "selector": {
      "deviceID": {
         "$eq": "device-123456"
      }
   }
}
```

{{site.data.keyword.cloudant_short_notm}} に要求を実行するとき、パーティションは次のように HTTP パスに埋め込まれます。

```
curl -XPOST \
    'https://acme.cloudant.com/readings/_partition/bridge-1234/_find' \
    -d @query.json
```

#### デバイスの最近の結果の照会
{: #querying-for-recent-results-for-a-device}

デバイスの結果を取得するには、`bridge-9876` パーティション内のデバイスに対してパーティション照会を実行します。選択子はもう少しだけ複雑になりますが、同等のグローバル照会とまだ同じです。

_query.json, assuming today is 13th Dec 2018:_

```json
{
   "selector": {
      "deviceID": {
         "$eq": "device-123456"
      },
      "ts": {
         "$gte": "20181213"
      }
   }
}
```

{{site.data.keyword.cloudant_short_notm}} に要求を実行するとき、パーティションは次のように HTTP パスに埋め込まれます。

```
curl -XPOST \
    'https://acme.cloudant.com/readings/_partition/bridge-1234/_find' \
    -d @query.json
```

---

copyright:
  years: 2015, 2018
lastupdated: "2018-10-24"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}

<!-- Acrolinx: 2018-05-07 -->

# 競合

データのコピーが複数の場所に保管される可能性がある分散データベースでは、ネットワークとシステムは、本来、ある場所に保管された文書に対して変更が行われても、データベースの他の部分の更新や複製を即時に行うことができないという特質があります。

つまり、独立した更新が文書のさまざまなコピーに行われる場合、何が文書の正しい最終的な内容であるかに関して不一致、つまり「競合」が生じることになる場合があります。

{{site.data.keyword.cloudantfull}} は、潜在的な問題を警告することで競合が回避されるようにします。
これを実現するために、問題のある更新要求に [`409` 応答](../api/http.html#http-status-codes)が返されます。
ただし、ネットワークに現在接続されていないシステムでデータベース更新が要求された場合、`409` 応答が表示されないことがあります。
例えば、データベースが、インターネットから一時的に切断されたモバイル・デバイス上にある場合、競合する可能性がある他の更新が行われたかどうかを確認することはその時点では不可能です。

競合状態になっている文書を要求した場合、{{site.data.keyword.cloudant_short_notm}} は予期したとおりに文書を返します。
ただし、返されるバージョンは、多数の要因を考慮する内部アルゴリズムによって決定されます。返された文書が常に最新バージョンであると想定するべきではありません。以下に例を示します。

競合があるかどうかを確認しなかったり、競合に対処しなかったりした場合、{{site.data.keyword.cloudant_short_notm}} データベースは、以下のいくつかの動作を示し始めます。

* 競合する文書の数が増えるため、文書の内容の不整合が増える。
* 競合が解決されるまで、競合するすべての文書を保持する必要があるため、データベース・サイズが増える。
* {{site.data.keyword.cloudant_short_notm}} は、競合する文書の「可能な限り最適な」バージョンを判別しようとして、すべての要求への応答でより集中的に処理を行う必要があるため、パフォーマンスが低下する。

競合があるかどうかを確認して解決するタイミングを決定する上で、提案されている以下の慣例が役立ちます。

<table>
<tr>
<th>アプリケーション特性</th>
<th>文書更新の頻度</th>
<th>取得時に競合を確認するかどうか</th>
<th>更新時に競合を確認するかどうか</th>
</tr>
<tr>
<td>ネットワークに常に接続されている (例えば、サーバー)。</td>
<td>多くの場合</td>
<td>はい</td>
<td>-</td>
</tr>
<tr>
<td>常にネットワークに接続されている。</td>
<td>場合により</td>
<td>-</td>
<td>はい</td>
</tr>
<tr>
<td>常時ではないが、多くの場合ネットワークに接続されている (例えば、ラップトップ)。</td>
<td>多くの場合</td>
<td>-</td>
<td>はい</td>
</tr>
<tr>
<td>常時ではないが、多くの場合ネットワークに接続されている。</td>
<td>場合により</td>
<td>-</td>
<td>はい</td>
</tr>
<tr>
<td>場合によりネットワークに接続されている (例えば、タブレット)。</td>
<td>多くの場合</td>
<td>-</td>
<td>はい</td>
</tr>
</table>

## 競合の検出

文書に影響を与える可能性がある競合を検出するには、文書の取得時に照会パラメーター `conflicts=true` を追加します。
返される結果の文書には `_conflicts` 配列が含まれており、これには競合するすべてのリビジョンのリストが入っています。

<div></div>

> 文書の競合を検出するためのマップ関数の例:

```
function(doc) {
  if (doc._conflicts) {
    emit(null, [doc._rev].concat(doc._conflicts));
    }
}
```

データベース内の複数の文書の競合を検出するには、[ビュー](../api/creating_views.html)を作成します。
示されている例のようなマップ関数を使用すると、競合のあるすべての文書のすべてのリビジョンを検出できます。

このようなビューがある場合、これを使用して、必要に応じて競合を検出して解決することができます。
または、複製が行われるたびにビューを照会して、競合を即時に特定して解決することができます。

## 競合の解決方法

競合を検出したら、以下の 4 ステップで解決することができます。

1.	競合するリビジョンを[取得](conflicts.html#get-conflicting-revisions)する。
2.	それらをアプリケーション内で[マージ](conflicts.html#merge-the-changes)するか、ユーザーにどうしたいか尋ねる。
3.	新しいリビジョンを[アップロード](conflicts.html#upload-the-new-revision)する。
4.	古いリビジョンを[削除](conflicts.html#delete-old-revisions)する。

<div></div>

> 文書の例 - 最初のバージョン。

```json
{
  "_id": "74b2be56045bed0c8c9d24b939000dbe",
    "_rev": "1-7438df87b632b312c53a08361a7c3299",
    "name": "Samsung Galaxy S4",
    "description": "",
    "price": 650
}
```

この実行方法の例について考えてみましょう。
オンラインショップ用の商品のデータベースがあると仮定します。
文書の最初のバージョンは、示されている例のようになります。

<div></div>

> 説明が追加された、文書の第 2 バージョン (最初のリビジョン)。

```json
{
  "_id": "74b2be56045bed0c8c9d24b939000dbe",
    "_rev": "2-61ae00e029d4f5edd2981841243ded13",
    "name": "Samsung Galaxy S4",
    "description": "Latest smartphone from Samsung",
    "price": 650
}
```

この文書にはまだ説明がないため、他のユーザーが説明を追加する場合があります。

<div></div>

> 文書の最初のバージョンに値下げデータの変更が行われた_別の_ 第 2 バージョン。

```json
{
  "_id": "74b2be56045bed0c8c9d24b939000dbe",
    "_rev": "2-f796915a291b37254f6df8f6f3389121",
    "name": "Samsung Galaxy S4",
    "description": "",
    "price": 600
}
```

それと同時に、複製されたデータベースで作業をしている他のユーザーが価格を下げます。
この変更は、文書の最初のバージョンに対して行われます。
そのため、値下げの変更では説明の変更は「認識」されません。

後で 2 つのデータベースが複製されるときに、文書の 2 つの異なるバージョンのどちらが正しいかが明確ではないことがあります。
これが競合シナリオです。

## 競合するリビジョンの取得

文書の競合するリビジョンを検出するには、
通常どおりその文書を取得しますが、
以下の例のように `conflicts=true` パラメーターを
含めます。

`http://ACCOUNT.cloudant.com/products/$_ID?conflicts=true`

<div></div>

> 競合するリビジョンを示す、文書の取得に対する応答例

```json
{
  "_id":"74b2be56045bed0c8c9d24b939000dbe",
    "_rev":"2-f796915a291b37254f6df8f6f3389121",
    "name":"Samsung Galaxy S4",
    "description":"",
    "price":600,
    "_conflicts":["2-61ae00e029d4f5edd2981841243ded13"]
}
```

文書に競合がある場合、変更された説明または変更された価格の問題に基づく、示されている例のような応答が表示されることがあります。

変更された価格を持つバージョンは、文書の最新バージョンとして_任意に_ 選択されています。
最後に更新されたバージョンの文書が、競合解決用の最新バージョンであると見なされると想定すべきではありません。

この例では、`_rev` 値 `2-f796915a291b37254f6df8f6f3389121` を持つ取得済みの文書と、`_rev` 値 `2-61ae00e029d4f5edd2981841243ded13` を持つ別の文書の間に競合が存在すると考えられています。
競合する文書の詳細は `_conflicts` 配列に示されています。

多くの場合、
配列に 1 つの要素しかなくても、
競合する多数のリビジョンが存在している可能性があり、
それぞれのリビジョンは、その配列にリストされます。

## 変更のマージ

アプリケーションは、可能性がある変更をすべて識別して調整することで、正しい有効な更新を効率的にマージすることにより、その文書の競合しない単一のバージョンを生成する必要があります。

リビジョンを比較して、変更された内容を識別するには、アプリケーションはデータベースからすべてのバージョンを取得する必要があります。
前述したように、まず、1 つの文書および競合するすべてのバージョンの詳細を取得します。
これを行うには、次のようなコマンドを使用します。このコマンドによって、`_conflicts` 配列も要求されます。

`http://$ACCOUNT.cloudant.com/products/$_ID?conflicts=true`

このように取得することで、保管した文書の最新バージョン、_および_ 同時に取得する必要があるその他の競合するすべての文書 (`...rev=2-61ae00e029d4f5edd2981841243ded13` や `...rev=1-7438df87b632b312c53a08361a7c3299`) のリストが提供されます。
これらのその他の競合する各バージョンも取得および保管されます。以下に例を示します。

  `http://$ACCOUNT.cloudant.com/products/$_ID?rev=2-61ae00e029d4f5edd2981841243ded13`
  `http://$ACCOUNT.cloudant.com/products/$_ID?rev=1-7438df87b632b312c53a08361a7c3299`

文書の競合するリビジョンをすべて入手したら、競合の解決に進むことができます。

前のシナリオでは、文書のバージョン間の違いは文書内の異なるフィールドに関するものだったため、より簡単にマージできました。

より複雑な競合では、それに対応してさらに分析が必要になる可能性があります。
これに役立つように、以下のようなさまざまな競合解決戦略の中から選択できます。

*	時間基準: 最初の編集または最後の編集の単純なテストを使用する。
*	ユーザー評価: 競合はユーザーに報告され、その後そのユーザーが最良の解決策を決定する。
*	洗練されたマージ・アルゴリズム: これは、多くの場合[バージョン管理システム](https://en.wikipedia.org/wiki/Merge_%28version_control%29)で使用される。 例えば、[3 方向マージ](https://en.wikipedia.org/wiki/Merge_%28version_control%29#Three-way_merge)。

これらの変更を実装する方法の実例については、[サンプル・コードを含むこのプロジェクト](https://github.com/glynnbird/deconflict)を参照してください。

## 新しいリビジョンのアップロード

> 解決し、前の競合するリビジョンからの変更をマージした、最終リビジョン。

```json
{
  "_id": "74b2be56045bed0c8c9d24b939000dbe",
    "_rev": "3-daaecd7213301a1ad5493186d6916755",
    "name": "Samsung Galaxy S4",
    "description": "Latest smartphone from Samsung",
    "price": 600
}
```

競合を評価して解決した後で、
現行の確定版データを含む文書を作成します。
この新しい文書がデータベースにアップロードされます。

## 古いリビジョンの削除

> 古いリビジョンを削除するための要求の例。

```http
DELETE http://$ACCOUNT.cloudant.com/products/$_ID?rev=2-61ae00e029d4f5edd2981841243ded13

DELETE http://$ACCOUNT.cloudant.com/products/$_ID?rev=2-f796915a291b37254f6df8f6f3389121
```

最終ステップでは、古いリビジョンを削除します。
これを行うには、削除するリビジョンを指定して、`DELETE` 要求を送信します。

文書の古いバージョンが削除されると、その文書に
関連付けられた競合には解決済みのマークが付けられます。
[前述のように](conflicts.html#finding-conflicts) `conflicts` パラメーターを true に設定して文書を再度要求することで、競合が残っていないことを検証することができます。

---

copyright:
  years: 2022, 2023
lastupdated: "2023-03-31"

keywords: api, http, database, partitioned query, eventual consistency, time box

subcollection: Cloudant

---

{{site.data.keyword.attribute-definition-list}}

# Data modeling
{: #data-modeling}

The Data modeling document is the first best practice document in the series. It shows you the following best practices: 

- What you need to know about your APIs.
- How to model your data.
- What size documents you must use.
- What to avoid.
- How to configure your databases.
{: shortdesc}

For more information, see [Indexing and querying](/docs/Cloudant?topic=Cloudant-indexing-and-querying) or [{{site.data.keyword.cloudant_short_notm}} in practice](/docs/Cloudant?topic=Cloudant-cloudant-in-practice).

The content in this document was originally written by Stefan Kruger as a [*Best and worst practice*](https://blog.cloudant.com/2019/11/21/Best-and-Worst-Practices.html) blog post on 21 November 2019.

## Understand the API that you are targeting
{: #understand-api-you-target}

You can use [Java&trade;](https://github.com/IBM/cloudant-java-sdk){: external}, [Python](https://github.com/IBM/cloudant-python-sdk){: external}, [Go](https://github.com/IBM/cloudant-go-sdk){: external}, or [Node.js](https://github.com/IBM/cloudant-node-sdk){: external} or some other use-case-specific language or platform. One of these languages most likely comes with convenient client-side libraries that integrate {{site.data.keyword.cloudant_short_notm}} access nicely, following the conventions that you expect for your tools. These languages are great for programmer efficiency, but they also hide the API from view.

This abstraction is what you want, the whole reason for using a client library is to save yourself repeated, tedious boiler-plating. However, you must understand the underlying API is vital when you troubleshoot and when you report problems. When you report a suspected problem to {{site.data.keyword.cloudant_short_notm}}, it helps us help you if you can provide a way for us to reproduce the problem.

This request does not mean cutting and pasting a hefty chunk of your application’s Java&trade; source verbatim into a support ticket, as we’re probably not able to build it. Also, your client-side code introduces uncertainties as to where the problem might be, your side or our side?

Instead, {{site.data.keyword.cloudant_short_notm}}’s support teams usually ask you to provide the set of API calls, ideally as a set of [curl](https://curl.se/){: external} commands that they can run, that demonstrates the issue. Adopting this approach to troubleshooting as a rule also makes it easier for you to pinpoint where issues are failing. If your code is behaving unexpectedly, try to reproduce the problem by using only direct access to the API.

If you can’t, the problem isn’t with the {{site.data.keyword.cloudant_short_notm}} service itself.

If you’re investigating a performance issue, do consult the logs that are provided by {{site.data.keyword.cloud}}. If the logs show that your requests are handled quickly by {{site.data.keyword.cloudant_short_notm}}, but your application is slow, the root of that problem lies with your client-side application code. See the rule about [logging and monitoring](/docs/Cloudant?topic=Cloudant-cloudant-in-practice#see-whats-going-on-with-logs).

If you suspect that a problem lies with an officially supported client library, then try to construct a small, self-contained code example that demonstrates the issue. In this self-contained code example, use as few other dependencies as possible. If you’re using Java&trade;, it is helpful to us if you can use a minimal [test harness](https://github.com/mikerhodes/java-cloudant-minimal){: external} to highlight library issues.

Occasionally, {{site.data.keyword.cloudant_short_notm}} receives support tickets that state that “{{site.data.keyword.cloudant_short_notm}} is broken because my application is slow” without much in terms of supporting evidence. Nearly always this case can be traced back to issues in the application code on the client side, or misconceptions about how {{site.data.keyword.cloudant_short_notm}} works.

Not always, but nearly always.

By understanding the API better, you also gain experience in how {{site.data.keyword.cloudant_short_notm}} behaves, especially in terms of performance. If you’re using a client library, you must aim to at least know how to find out which HTTP requests are generated by a specific function call. For more information, see the following websites:

- {{site.data.keyword.cloudant_short_notm}} [API docs](/apidocs/cloudant){: external}
- Logging [integration](/docs/Cloudant?topic=Cloudant-log-analysis-integration){: external}
- Blog post on [logging](https://blog.cloudant.com/2019/09/16/Cloudant-Logging-with-LogDNA.html){: external}

## Documents must group data that mostly changes together
{: #documents-group-data-change}

When you start to model your data, sooner or later, you run into the issue of how your documents might be structured. Now you know that {{site.data.keyword.cloudant_short_notm}} doesn’t enforce any normalization and that it has no transactions of the type you’re used to from, say, [Postgres](https://www.postgresql.org/){: external}. The temptation can be to cram as much as possible into each document, which would also save on HTTP usage.

This practice is often a bad idea.

If your model groups information that doesn’t change together, you’re more likely to suffer from update conflicts.

Consider a situation where you have users, each with a set of orders associated with them. One way might be to represent the orders as an array in the user document:

```json
{ // DON'T DO THIS
    "customer_id": 65522389,
    "orders": [ {
      "order_id": 887865,
      "items": [ {
          "item_id": 9982,
          "item_name": "Iron sprocket",
          "cost": 53.0
        }, {
          "item_id": 2932,
          "item_name": "Rubber wedge",
          "cost": 3.0
        }
      ]
    }
  ]
}
```
{: codeblock}

To add an order, I need to fetch the complete document, unmarshal the JSON, add the item, marshal the new JSON, and send it back as an update. If I’m the only one doing so, it might work for a while. If the document is being updated concurrently, or being replicated, we might likely see update conflicts.

Instead, keep orders separate as their own document type, referencing the customer ID. Now the model is immutable. To add an order, I simply create a new order document in the database, which cannot generate conflicts.

To be able to retrieve all orders for a specific customer, we can employ a view, which we cover later.

Avoid constructs that rely on updates to parts of existing documents, where possible. Bad data models are often hard to change once you’re in production.

The previous pattern can be solved efficiently by using partitioned databases, which are covered in greater detailed later.

For more information, see the following documentation:

- {{site.data.keyword.cloudant_short_notm}} guide to [data modeling](/docs/Cloudant?topic=Cloudant-five-tips-for-modeling-your-data-to-scale-faq)
- [Database partitions](/docs/Cloudant?topic=Cloudant-database-partitioning){: external}

## Keep documents small
{: #keep-documents-small}

{{site.data.keyword.cloudant_short_notm}} imposes a max doc size of 1 MB. This limit does not mean that a close-to-1-MB document size is a good idea. On the contrary, if you find you are creating documents that exceed single-digit KB, you probably need to revisit your model. Several things in {{site.data.keyword.cloudant_short_notm}} become less performant as documents grow. JSON decoding is costly, for example.

Let's look at the following sections: *Documents must group data that mostly changes together* and *Keep documents small*. It’s worth stressing that models that rely on updates have a maximum volume limit of 1 MB, the cut-off for document size. This size isn’t what you want.

## Avoid using attachments
{: #avoid-using-attachments}

{{site.data.keyword.cloudant_short_notm}} has support for storing attachments alongside documents, a long-standing feature it inherits from CouchDB. If you’re using {{site.data.keyword.cloudant_short_notm}} as a backend for a web application, it can be handy to store small icons and other static assets such as CSS and JavaScript files with the data.

You must consider a few things before you use attachments in {{site.data.keyword.cloudant_short_notm}} today, especially if you’re looking at larger assets such as images and videos:

1. {{site.data.keyword.cloudant_short_notm}} is expensive as a block store. 
2. {{site.data.keyword.cloudant_short_notm}}’s internal implementation is not efficient in handling large amounts of binary data.

So, slow and expensive.

{{site.data.keyword.cloudant_short_notm}} is acceptable for small assets and occasional use. As a rule, if you need to store binary data alongside {{site.data.keyword.cloudant_short_notm}} documents, it’s better to use a separate solution more suited for this purpose. You need only store the attachment *metadata* in the {{site.data.keyword.cloudant_short_notm}} document. Yes, that means you need to write some extra code to upload the attachment to a suitable block store of your choice. Verify that it succeeded before you store the token or URL to the attachment in the {{site.data.keyword.cloudant_short_notm}} document.

Your databases are smaller, cheaper, faster, and easier to replicate. For more information, see the following websites:

- {{site.data.keyword.cloudant_short_notm}} docs on [attachments](/docs/Cloudant?topic=Cloudant-how-to-use-attachments)
- Detaching {{site.data.keyword.cloudant_short_notm}} attachments to [Object Storage](https://medium.com/codait/detaching-cloudant-attachments-to-object-storage-with-serverless-functions-99b8c3c77925){: external}

## Fewer databases are better than many
{: #fewer-dbs-better-than-many}

If you can, limit the number of databases per {{site.data.keyword.cloudant_short_notm}} account to 500 or fewer. While this particular number is not magic (IBM Cloudant can safely handle more), several use cases exist that are adversely affected by large numbers of databases in an account.

The replicator scheduler has a limited number of simultaneous replication jobs that it is prepared to run. As the number of databases grows, the replication latency is likely to increase if you try to replicate everything contained in an account.

The flip side of the same coin is the operational aspect: {{site.data.keyword.cloudant_short_notm}}’s operations team relies on replication, too, to move around accounts. By keeping down the number of databases, you help us help you if you need to shift your account from one location to another.

So when must you use a single database and distinguish between different document types by using views, and when must you use multiple databases to model your data? {{site.data.keyword.cloudant_short_notm}} can’t federate views across multiple databases. If you have unrelated data that can never be “joined” or queried together, then that data could be a candidate for splitting across multiple databases.

If you have an ever-growing data set (like a log, sensor readings, or other types of time-series), it’s also not a good idea to create a single, ever-growing, massive database. This kind of use case requires time-boxing, which we cover in more detail later.
{: note}

## Avoid the *database per user* anti-pattern like the plague
{: #avoid-db-per-user}

If you’re building a multi-user service on top of {{site.data.keyword.cloudant_short_notm}}, it is tempting to let each user store their data in a separate database under the application account. That works well, mostly, if the number of users is small.

Now add the need to derive cross-user analytics. The way that you do that is to replicate all the user databases into a single analytics database. All good. This app has suddenly become successful, and the number of users grew in the range of 150 - 20,000. You have 20,000 replications just to keep the analytics database current. If you also want to run in an active-active disaster recovery setup, add another 20,000 replications, and the system stops functioning.

Instead, multiplex user data into fewer databases, or shard users into a set of databases or accounts, or both. That way, you do not need to replicate to provide an analytics database, but authentication becomes more complicated as {{site.data.keyword.cloudant_short_notm}} provides only authentication at the database level.

It’s worth stating that the “database-per-user” approach is tempting because {{site.data.keyword.cloudant_short_notm}} permissions are “per database”, but it’s not really the users’ fault that this pattern emerged.

## Avoid writing custom JavaScript reduce functions
{: #avoid-custom-javascript-reduce-functions}

The MapReduce views in {{site.data.keyword.cloudant_short_notm}} are awesome. However, with great power comes great responsibility. The map part of a MapReduce view is built incrementally, so shoddy code in the map impacts only indexing time, not query time. The reduce-part, unfortunately, executes at query time. {{site.data.keyword.cloudant_short_notm}} provides a set of built-in reduce functions that are implemented internally in [Erlang](https://www.erlang.org/){: external}, which are performant at scale, and which your hand-crafted JavaScript reduces are not.

If you find yourself writing reduce functions, stop and consider whether you could reorganize your data so that writing reduce functions isn’t necessary. Or so that you’re able to rely on the built-in reducers. 

Views on partitioned databases do not support custom reduces, which is one factor that contributes to the significant speed-up queries only such views can offer.
{: note}

For more information, see {{site.data.keyword.cloudant_short_notm}} docs on [reduces](/docs/Cloudant?topic=Cloudant-creating-views-mapreduce#reduce-functions){: external}.

## Use time boxed databases for ever-growing data sets
{: #timebox-dbs-growing-data-sets}

It’s generally *not* a good idea to have an ever-growing database in {{site.data.keyword.cloudant_short_notm}}. Large databases can be difficult to back up, require “resharding” to maintain good performance as they grow, and suffer from long index build times.

One way of mitigating this problem is to have several smaller databases instead, with a common pattern that is *time-boxed databases*: a large data set is split into smaller databases, each representing a time window, for example, a month.

- `orders_2019_01`
- `orders_2019_02`
- `orders_2019_02`

New data is written to this month’s database and queries for historical data can be directed to previous months’ databases. When a month’s data is no longer of interest, it can be archived to Object Storage, the monthly {{site.data.keyword.cloudant_short_notm}} database is deleted, and the disk space recovered. For more information, see the following website.

- [Time-series Data Storage blog](https://blog.cloudant.com/2019/04/08/Time-series-data-storage.html){: external}

---

copyright:
  years: 2022
lastupdated: "2022-05-17"

keywords: api, http, database, partitioned query, eventual consistency, timebox

subcollection: Cloudant

---

{{site.data.keyword.attribute-definition-list}}

# Data modeling
{: #data-modeling}

If you're new to {{site.data.keyword.cloudantfull}}, but you're not new to database systems, the following information discusses the suggested practices from someone who has seen the product from all angles: 
- The customers who use it.
- The engineers who run it.
- The folks who support and sell it.
{: shortdesc}

For more information, see [Indexing and querying](/docs/Cloudant?topic=Cloudant-indexing-and-querying) or [{{site.data.keyword.cloudant_short_notm}} in practice](/docs/Cloudant?topic=Cloudant-cloudant-in-practice).

The content in this document was originally written by Stefan Kruger as a [*Best and worst practice*](https://blog.cloudant.com/2019/11/21/Best-and-Worst-Practices.html) blog post on 21 November 2019.

## Understand the API you are targeting
{: #understand-api-you-target}

You can use [Java](https://github.com/IBM/cloudant-java-sdk){: external}, [Python](https://github.com/IBM/cloudant-python-sdk){: external}, [Go](https://github.com/IBM/cloudant-go-sdk){: external} or [Node.js](https://github.com/IBM/cloudant-node-sdk){: external} or some other use-case-specific language or platform that likely comes with convenient client-side libraries that integrate {{site.data.keyword.cloudant_short_notm}} access nicely, following the conventions you expect for your tools. These languages are great for programmer efficiency, but they also hide the API from view.

This abstraction is what you want, of course—the whole reason for using a client library is to save yourself repeated, tedious boiler-plating—but understanding the underlying API is vital when you troubleshoot and when you report problems. When you report a suspected problem to {{site.data.keyword.cloudant_short_notm}}, it helps us help you if you can provide a way for us to reproduce the problem.

This does not mean cutting and pasting a hefty chunk of your application’s Java source verbatim into a support ticket, as we’re probably not able to build it. Also, your client-side code introduces uncertainties as to where the problem may be—your side or our side?

Instead, {{site.data.keyword.cloudant_short_notm}}’s support teams usually ask you to provide the set of API calls, ideally as a set of [curl](https://curl.se/){: external} commands that they can run, that demonstrates the issue. Adopting this approach to troubleshooting as a general rule also makes it easier for you to pinpoint where issues are failing. If your code is behaving unexpectedly, try to reproduce the problem using only direct access to the API.

If you can’t, the problem isn’t with the {{site.data.keyword.cloudant_short_notm}} service itself.

If you’re investigating a performance issue, do consult the logs provided by {{site.data.keyword.cloud}}. If the logs show that your requests are handled quickly by {{site.data.keyword.cloudant_short_notm}}, but your application is slow, the root of that problem lies with your client-side application code. See the rule about logging and monitoring below.

If you suspect that a problem you’ve encountered lies with an officially supported client library, then try to construct a small, self-contained code example that demonstrates the issue, with as few other dependencies as possible. If you’re using Java, it is helpful to us if you can use a minimal [test harness](https://github.com/mikerhodes/java-cloudant-minimal){: external} to highlight library issues.

Occasionally, {{site.data.keyword.cloudant_short_notm}} receives support tickets that state that “{{site.data.keyword.cloudant_short_notm}} is broken because my application is slow” without much in terms of supporting evidence. Nearly always this is traced back to issues in the application code on the client side, or misconceptions about how {{site.data.keyword.cloudant_short_notm}} works.

Not always, but nearly always.

By understanding the API better, you also gain experience in how {{site.data.keyword.cloudant_short_notm}} behaves, especially in terms of performance. If you’re using a client library, you should aim to at least know how to find out which HTTP requests are generated by a given function call. For more information, see the following websites:

- {{site.data.keyword.cloudant_short_notm}} [API docs](/apidocs/cloudant){: external}
- Logging [integration](/docs/Cloudant?topic=Cloudant-log-analysis-integration){: external}
- Blog post on [logging](https://blog.cloudant.com/2019/09/16/Cloudant-Logging-with-LogDNA.html){: external}

## Documents must group data that mostly changes together
{: #documents-group-data-change}

When you start to model your data, sooner or later, you’ll run into the issue of how your documents should be structured. You’ve gleaned that {{site.data.keyword.cloudant_short_notm}} doesn’t enforce any normalization and that it has no transactions of the type you’re used to from, say, [Postgres](https://www.postgresql.org/){: external}. The temptation can be to cram as much as possible into each document, given that this would also save on HTTP usage.

This practice is often a bad idea.

If your model groups information that doesn’t change together, you’re more likely to suffer from update conflicts.

Consider a situation where you have users, each with a set of orders associated with them. One way might be to represent the orders as an array in the user document:

```json
{ // DON'T DO THIS
    "customer_id": 65522389,
    "orders": [ {
      "order_id": 887865,
      "items": [ {
          "item_id": 9982,
          "item_name": "Iron sprocket",
          "cost": 53.0
        }, {
          "item_id": 2932,
          "item_name": "Rubber wedge",
          "cost": 3.0
        }
      ]
    }
  ]
}
```
{: codeblock}

To add a new order, I need to fetch the complete document, unmarshal the JSON, add the item, marshal the new JSON, and send it back as an update. If I’m the only one doing so, it may work for a while. If the document is being updated concurrently, or being replicated, we’ll likely see update conflicts.

Instead, keep orders separate as their own document type, referencing the customer ID. Now the model is immutable. To add a new order, I simply create a new order document in the database, which cannot generate conflicts.

To be able to retrieve all orders for a given customer, we can employ a view, which we’ll cover later.

Avoid constructs that rely on updates to parts of existing documents, where possible. Bad data models are often extremely hard to change once you’re in production.

The pattern above can be solved efficiently using partitioned databases, which are covered in greater detailed later.

For more information, see the following documentation:

- {{site.data.keyword.cloudant_short_notm}} guide to [data modeling](/docs/Cloudant?topic=Cloudant-five-tips-for-modeling-your-data-to-scale-faq)
- [Database partitions](/docs/Cloudant?topic=Cloudant-database-partitioning){: external}

## Keep documents small
{: #keep-documents-small}

{{site.data.keyword.cloudant_short_notm}} imposes a max doc size of 1 MB. This does not mean that a close-to-1-MB document size is a good idea. On the contrary, if you find you are creating documents that exceed single-digit KB in size, you should probably revisit your model. Several things in {{site.data.keyword.cloudant_short_notm}} become less performant as documents grow. JSON decoding is costly, for example.

Given sections *Why must my documents group data that mostly changes together?* and *Why must I keep documents small?*, it’s worth stressing that models that rely on updates have an upper volume limit of 1MB–the cut-off for document size. This isn’t what you want.

## Avoid using attachments
{: #avoid-using-attachments}

{{site.data.keyword.cloudant_short_notm}} has support for storing attachments alongside documents, a long-standing feature it inherits from CouchDB. It can be handy to be able to store small icons and other static assets such as CSS and JavaScript files with the data if you’re using {{site.data.keyword.cloudant_short_notm}} as a backend for a web application.

There are a few things to consider before using attachments in {{site.data.keyword.cloudant_short_notm}} today, especially if you’re looking at larger assets such as images and videos:

1. {{site.data.keyword.cloudant_short_notm}} is expensive as a block store. 
2. {{site.data.keyword.cloudant_short_notm}}’s internal implementation is not efficient in handling large amounts of binary data.

So: slow and expensive.

It’s acceptable for small assets and occasional use, but as a rule, if you need to store binary data alongside {{site.data.keyword.cloudant_short_notm}} documents, it’s better to use a separate solution more suited for this purpose, and store only the attachment *metadata* in the {{site.data.keyword.cloudant_short_notm}} document. Yes, that means some extra code you need to write to upload the attachment to a suitable block store of your choice. Verify that it succeeded before storing the token or URL to the attachment in the {{site.data.keyword.cloudant_short_notm}} document.

Your databases will be smaller, cheaper, faster, and easier to replicate. For more information, see the following websites:

- {{site.data.keyword.cloudant_short_notm}} docs on [attachments](/docs/Cloudant?topic=Cloudant-how-to-use-attachments)
- Detaching {{site.data.keyword.cloudant_short_notm}} attachments to [Object Storage](https://medium.com/codait/detaching-cloudant-attachments-to-object-storage-with-serverless-functions-99b8c3c77925){: external}

## Fewer databases are better than many
{: #fewer-dbs-better-than-many}

If you can, limit the number of databases per {{site.data.keyword.cloudant_short_notm}} account to 500 or fewer. Whilst there is nothing magic about this particular number, ({{site.data.keyword.cloudant_short_notm}} can safely handle more), there are several use cases that are adversely affected by large numbers of databases in an account.

The replicator scheduler has a limited number of simultaneous replication jobs it is prepared to run. That means that as the number of databases grow, the replication latency is likely to increase if you try to replicate everything contained in an account.

There is an operational aspect that is the flip side of the same coin: {{site.data.keyword.cloudant_short_notm}}’s operations team relies on replication, too, to move accounts around. By keeping down the number of databases, you help us help you if you need to shift your account from one location to another.

So when must you use a single database and distinguish between different document types using views, and when must you use multiple databases to model your data? {{site.data.keyword.cloudant_short_notm}} can’t federate views across multiple databases, so if you have unrelated data to the extent that it will never be “joined” or queried together, then that data could be a candidate for splitting across multiple databases.

If you have an ever-growing data set (like a log, sensor readings, or other types of time-series), it’s also not a good idea to create a single, ever-growing, massive database. This kind of use case requires time-boxing, which we cover in more detail later.
{: note}

## Avoid the "database per user" anti-pattern like the plague
{: #avoid-db-per-user}

If you’re building out a multi-user service on top of {{site.data.keyword.cloudant_short_notm}}, it is tempting to let each user store their data in a separate database under the application account. That works well, mostly, if the number of users is small.

Now add the need to derive cross-user analytics. The way you do that is to replicate all the user databases into a single analytics database. All good. This app has suddenly become successful, and the number of users has grown from 150 to 20,000. You have 20,000 replications just to keep the analytics database current. If you also want to run in an active-active disaster recovery setup, add another 20,000 replications, and the system will stop functioning.

Instead, multiplex user data into fewer databases, or shard users into a set of databases or accounts, or both. That way, there is no need to replicate to provide an analytics database, but authentication becomes more complicated as {{site.data.keyword.cloudant_short_notm}} only provides authentication at the database level.

It’s worth stating that the “database-per-user” approach is tempting because {{site.data.keyword.cloudant_short_notm}} permissions are “per database”—it’s not really the users’ fault that this pattern has emerged.

## Avoid writing custom JavaScript reduce functions
{: #avoid-custom-javascript-reduce-functions}

The map-reduce views in {{site.data.keyword.cloudant_short_notm}} are awesome. However, with great power comes great responsibility. The map part of a map-reduce view is built incrementally, so shoddy code in the map impacts only indexing time, not query time. The reduce-part, unfortunately, executes at query time. {{site.data.keyword.cloudant_short_notm}} provides a set of built-in reduce functions that are implemented internally in [Erlang](https://www.erlang.org/){: external}, which are performant at scale, and which your hand-crafted JavaScript reduces are not.

If you find yourself writing reduce functions, stop and consider if you could reorganize your data so that this isn’t necessary or so that you’re able to rely on the built-in reducers. 

Views on partitioned databases do not support custom reduces, which is one factor contributing to the significant speed-up queries on such views can offer.
{: note}

For more information, see {{site.data.keyword.cloudant_short_notm}} docs on [reduces](/docs/Cloudant?topic=Cloudant-creating-views-mapreduce#reduce-functions){: external}.

## Use timeboxed databases for ever-growing data sets
{: #timebox-dbs-growing-data-sets}

It’s generally *not* a good idea to have an ever-growing database in {{site.data.keyword.cloudant_short_notm}}. Very large databases can be difficult to back up, require “re-sharding” to maintain good performance as they grow, and suffer from long index build times.

One way of mitigating this problem is to have several smaller databases instead, with a very common pattern being *time-boxed databases*: a large data set is split into smaller databases, each representing a time window, for example, a month.

- `orders_2019_01`
- `orders_2019_02`
- `orders_2019_02`

New data is written to this month’s database and queries for historical data can be directed to previous months’ databases. When a month’s data is no longer of interest, it can be archived to Object Storage, the monthly {{site.data.keyword.cloudant_short_notm}} database deleted and the disk space recovered. For more information, see the following website.

- [Time-series Data Storage blog](https://blog.cloudant.com/2019/04/08/Time-series-data-storage.html){: external}
